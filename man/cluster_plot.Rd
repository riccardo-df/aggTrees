% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/visualization.R
\name{cluster_plot}
\alias{cluster_plot}
\title{Cluster Plot}
\usage{
cluster_plot(clusters, cates, X, plot = NULL, low = "yellow", high = "red")
}
\arguments{
\item{clusters}{The output of \code{\link{kmeans}} or \code{\link[T4cluster]{kmeanspp}}.}

\item{cates}{CATEs vector.}

\item{X}{Covariate matrix (no intercept). The same used in \code{aggregation_tree}.}

\item{plot}{Optional, the output of \code{\link{recursive_partitioning_plot}}. If provided, the cluster plot is overimposed to \code{plot}.}

\item{low}{String. Color to represent more negative \code{cates}. Ignored if \code{plot} is provided.}

\item{high}{String. Color to represent more positive \code{cates}. Ignored if \code{plot} is provided.}
}
\value{
The desired plot.
}
\description{
Plots the average values of the covariates for each cluster in a two-dimensional covariate space. Useful to compare
clustering methods with aggregation trees.
}
\details{
\code{cluster_plot} helps visualizing how clustering methods compress the information of the \code{cates}. \cr\cr
The plot is built as follows. First, a scatter plot of the two covariates is displayed. Each point is colored
according to the associated value of \code{cates}, so that it is immediate noticing where treatment effects
are stronger and lighter (colors can be specified by the user). Second, additional points are overimposed, one
for each cluster. The coordinates of these points correspond to the average value of \code{X[, 1]} and \code{X[, 2]}
for the associated cluster.
}
\examples{
## Loading data (using random subsample provided by Matias Cattaneo).
dta <- haven::read_dta("http://www.stata-press.com/data/r13/cattaneo2.dta")

Y <- as.matrix(dta[, "bweight"])
D <- as.matrix(dta[, "mbsmoke"])
X_names <- c("bweight", "mbsmoke", "deadkids", "monthslb", "lbweight")
X <- as.matrix(dta[, !(colnames(dta) \%in\% X_names)])

## Splitting sample.
set.seed(1986)
n <- dim(dta)[1]
est_idx <- sample(1:n, n / 2, replace = FALSE)

X_est <- X[est_idx, ]
Y_est <- Y[est_idx]
D_est <- D[est_idx]

X_agg <- X[-est_idx, ]
Y_agg <- Y[-est_idx]
D_agg <- D[-est_idx]

## Estimating CATEs using only estimation sample.
cates_forest <- grf::causal_forest(X = X_est, Y = Y_est, W = D_est)

## Clustering using only aggregation sample.
cates <- predict(cates_forest, newdata = X_agg)$predictions
clusters <- kmeans(cates, 3)

## Plotting.
X_subsample <- as.data.frame(X_agg[, c("mage", "nprenatal")])
plot <- cluster_plot(clusters, cates, X_subsample)
plot

## Overlaying aggregation tree.
tree <- aggregation_tree(cates, X_subsample, maxdepth = 3, cp = 0.01)
tree_plot <- recursive_partitioning_plot(tree, cates, X_subsample)
cluster_plot <- cluster_plot(clusters, cates, X_subsample, plot = tree_plot)
cluster_plot

}
